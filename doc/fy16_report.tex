%\documentclass[review]{elsarticle}
\documentclass[preprint,3p]{elsarticle}

\usepackage{hyperref}
\usepackage{xspace}
\usepackage{tabularx}
\usepackage{array}
\usepackage{url}
\usepackage{fancyvrb}
\DefineShortVerb{\|}
%\usepackage{lineno}
%\modulolinenumbers[5]

\journal{Journal of Unpublished HAD Reports}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{Implementing DANE Email Testers}
\tnotetext[mytitlenote]{Fully documented templates are available in the elsarticle package on \href{http://www.ctan.org/tex-archive/macros/latex/contrib/elsarticle}{CTAN}.}

%% Group authors per affiliation:
\author{Simson Garfinkel}

\begin{abstract}
DNS-Based Authentication of Named Entities (DANE) can be used to
improve the trustworthiness of email by providing a discovery
mechanism for certificates and public keys that are used to secure the  SMTP communications
between Mail Transfer Agents (MTAs) and to encrypt email. A testing
frameworks for each of these DANE applications was created. The SMTP
tester uses a conventional logic-driven approach for test
frameworks, while the OPENPGP and SMIMEA testers employ a
database-driven testing framework that implements the tester as a
state machine. The two approaches are compared in terms of
development time, functionality, and extensibility.
\end{abstract}

\begin{keyword}
DNS-Based Authentication of Named Entities\sep DANE\sep OPENPGP\sep SMIMEA\sep 
\end{keyword}

\end{frontmatter}

%\linenumbers

\section{Introduction}

Public key discovery and certification has been one of the primary
barriers to realizing the benefit of email security
protocols. 

Although many SMTP servers now implement the STARTTLS SMTP
command\cite{rfc3207}, Mail Transfer Agents (MTAs) typically
certificates signed by \emph{any} Certificate Authority (CA)
(including self-signed certificates), as SMTP servers generally lack a
list of pre-configured certificate authorities and a user interface
that could be used to specify the disposition of mail that is being
sent to a mail server that has a certificate that is signed by an
unknown CA. Since mail is sent by default without encryption, this
so-called ``opportunitist encryption'' at least provides security
against a passive monitoring attacker.

After more than two decades of research and standards development
(e.g. \cite{rfc1421,rfc4880,rfc5750}), two incompatiable standards
have emerged for the exchange of encrypted Internet email: S/MIME and
PGP. Both of these standards from the \emph{key discovery problem:} in
order to send a recipient an encrypted message, it is necessary to
first obtain the recipient's public key. Within a single organization,
this problem can be solved through the use of a enterprise
directory. S/MIME also has the advantage that digitally signed email
messages typically include the sender's public key in the PKCS\#7
attachment\cite{rfc2315}, allowing the recipient of a digitally signed
message to send an encrypted reply to the sender. However, when
sending email between organizations, there is currently no deployed
mechanism that can be used to find the recipient's S/MIME certificate
or PGP public key prior to the first message exchange.

DNS-Based Authentication of Named
Entities\cite{rfc7671} (DANE) provides a general mechanism for the
discovery of cryptographic keys associated with DNS-named. By relying
on the DNSSEC\cite{rfc3833} trust roots, DANE delegates control of the
names within an organization's DNS hierarchy to the administrative
unit that is in control of the organization's DNS. RFC7671 and RFC7672 provide a
discovery mechanism for a domain's certified SMTP MTA public key or
PEM certificate\cite{rfc7671,rfc7672}. Work is in progress on a mechanism for discovering
S/MIME certificates associated with email addresses
(|draft-ietf-dane-smime11|), and 
an experimental RFC was recently approved for associating OpenPGP public keys with email addresses\cite{rfc7929}.

We created a conventional tester for HTTP and SMTP servers in
Python. The tester consists of a python module that implements an
instrumented client that uses \texttt{getdns}\cite{getdns} to acquire a TLSA RR for either
an HTTP or SMTP server. The certificate is then used to verify a TLS
server reached through either HTTP or SMTP. The tester can be run from
command line or a web interface. Testing results are incorporated into
a data structure which can then be rendered as either text or HTML.

The conventional tester was implemented using commonly accepted
programming practices including object-oriented design,
modularization, and integrated tests. Nevertheless, it proved
difficult to develop, audit, and extend to new protocols. A particular
complication is the fact that whether a DANE validation succeeds or
fails depends on both the server's certificate and the results of DNS
queries, but DNS servers frequently give different answers to the same
questions as a result of caching, load balancing, network congestion,
and configuration changes. Thus, it is difficult to determine the
reason for code that suddenly starts or stops working.

Following the development of the conventional tester, we created a
tester for the draft SMIMEA and OpenPGP protocols. As a result of the
experience with the conventional HTTP and SMTP testers, we developed a
new tester framework based on the core idea of \emph{auditability},
which we define as ``the degree to which transactions can be traced
and audited through a system.'' The core design goal of the SMIME and
OpenPGP tester was to maintain a log of all DNS queries and responses
so that the tester's edicts could be reviewed and validated. Another
design goal was to enable a \emph{replay} capability, so that previous
queries and responses to be used for regression testing. In the
process of designing the new testing framework, we realized the entire
testing agent could be implemented as a state machine, with each phase
of the test corresponding to states and state transitions being
directed by the responses from the systems undergoing test.


\subsection{Availability}

The complete DANE tester is available from Github at \url{https://github.com/usnistgov/dane_tester}.

\section{HTTP and SMTP TLSA Tester}
We created a tool to test server certificates advertised using DANE
for validity. Our tester tests both HTTP and SMTP servers. 

\subsection{Overview}

The tool's operation is straightforward:

\begin{enumerate}
\item The user specifies a service to test (either an HTTPS URL or an
  email address).
\item Using getdns, the tester obtains the DANE announcements for the
  service. 
\item The tester connects to the service and reports if the server's
  public key is validated by any of the   certificates or public keys
  advertised through DNS TLSA records. 
\end{enumerate}

To perform these tests, the tester contains its own DANE
implementation. The implementation covers several specific cases,
including:

\begin{itemize}
\item If the DNS name maps to multiple IP addresses, each IP address
  is tested. (Different IP addresses may have different certificates.)
\item If the DNS name specifies a CNAME, the CNAMEs are followed until
  the end of the change. A DANE record is looked for both the original
  DNS name and the name pointed to be the CNAME chain.
\item If the mail delivery host specifies a mail exchanger (MX)
  record, then both the primary name and the exchangers are tested.
\end{itemize}

\subsection{System Requirements}

\paragraph{OpenSSL v 1.0.2h}
The TLSA tester tests certificate validity using the \verb+openssl+
command line program, which is called using Python's \verb+subprocess.Popen()+
facility. Testing requires the flags |-purpose|, |-trusted_first|,
|-partial_chain| and |-CAfile|. These flags are only available on
OpenSSL version 1.0.2h and above.

Because US Government deployments are likely to have the
most recent FIPS-140 accredited OpenSSL version installed, which is
currently OpenSSL version 0.9.8zh, the installing scripts download and
install a private copy of OpenSSL version 1.0.2h in the
\verb+/usr/local/ssl+ directory.

\paragraph{Python 2.7}
The TLSA tester also required that Python modules \verb+getdns+ and
\verb+M2Crypto+ be installed. The only version of Python that supports
both is Python 2.7, so these modules are added to the Python 2.7
installation, even if a version of Python 3 is installed.

\paragraph{M2Crypto} The Python package M2Crypto is used for some
certificate manipulations.

\paragraph{getdns} The TLSA tester uses getdns and Verisign's getdns Python
bindings. Numerous problems resulted from the decision to use getdns
and it was not used in the follow-on tester.

\paragraph{py.test} The Python test framework \texttt{py.test} is used
for unit tests. Be sure to use version the version of py.test for
Python 2.7.

\subsection{File Layout}

The tester is contained entirely in the {\tt tlsa/} directory of the
git repository. It is implemented as a Python module and a CGI
script. The tester consists of the following shown in Table~\ref{tlsa}.

\begin{table*}
\begin{tabularx}{\textwidth}{>{\tt}lX}
Makefile & Targets for configuring Centos 7 base system and compiling helper programs. \\
README.md & Documentation \\
ca-bundle.crt & File containing multiple PEM-encoded SSL certificates of ``Well known'' Certificate Authorities. Used for Certificate Usage 0, which validates against system trust anchors. \\
centose7-setup.bash & Script to configure Centos 7 system to run the tester. \\
dane\_check.cgi & CGI script to run the tester from a webserver.\\
dane\_checker.py & Python module that implements DANE tester. Called by dane\_check.cgi and runnable directly from the command line. Can output both TEXT and HTML data.\\
dnstree.py & A program to test the getdns system.\\
get\_altnames & The compiled executable for the \emph{get\_altnames.c} program.\\
get\_altnames.c & M2Crypto provides no mechanism to read the alternative names on the X509 certificate, so this helper program gets the alt names of a certificate provided on the command line and prints the names to stdout.\\
test\_dane.py & A test program using the py.test framework to test functions within the {\tt dane\_checker} module.\\
\end{tabularx}
\caption{Files in the tlsa/ tester directory}\label{tlsa}
\end{table*}

\subsection{Installation and Operation}

The DANE server tester can be run from the command line using the
|dane_checker.py| script or from a web browser by placing the
|dane_check.cgi| script and the associated files in a
CGI-enabled directory of a modern web server. 

\begin{enumerate}
\item You will likely need to download and install the current
  versions of unbound and getdns, as the versions shipped with Centos
  have bugs that prevent proper DNSSEC verification of CNAME RRs.
\item Set \verb|$DANESRC| to root of the cloned git repository
\item \verb|cd $DANESRC|
\item Run |make| to compile |get_altname|.
\item Run |py.test| to run the self-test.
\item Run |python2.7 dane_checker.py https://good.dane.verisignlabs.com| to test Verisign's known-good
  DANE https server.
\item Run |python2.7 dane_checker.py https://bad-sig.dane.verisignlabs.com| to test one of Verisign's
  known-bad DANE https servers.
\item Run |python2.7 dane_checker.py --test| to test all of the test vectors.
\item Access \url{https://hostname/directory/dane_check.cgi} to run
  the web-based tester
\end{enumerate}

\subsection{Theory of Operation}

To test a DANE server, the Python file |dane_checker.py| contains a
DANE implementation in Python. The test is coded as a series of
imperative statements that determine the name of the remote server,
perform DNS lookups to discover the IP address(es) on which the server
is running, fetch the server certificates, and then compare the server
certificates to the DNS announcements. 

Rather than printing out the results of the tests as they happen, the
testing infrastructure creates a data structure that contains a record
of each test that was performed and the results of the test. The
data structure can then be rendered as text or HTML as required by the
caller. 

The tests were developed by a
close reading of the DANE specifications. Each test is given a name
and a number. Each test description is then stored its own Python
object. The slots of the object are:

\begin{tabularx}{\textwidth}{llX}
test.num & int & Test number, assigned by the author.\\
test.desc & str & A description of the test, in English.\\
test.section & str & The section of the DANE RFC from which the test derives.\\
test.failed\_desc & str & What to print if the test fails.\\
test.recommendation & boolean & If the test is for a recommended usage, but not a mandatory usage.\\
\end{tabularx}

The test numbers are assigned in these ranges:

\begin{tabular}{ll}
101-104 & DNS tests \\
201-205 & Server verification\\
301-308 & Certificate verification\\
401-407 & Ensemble results\\
\end{tabular}

When |dane_checker.py| loads the \emph{MakeTest} objects are created
and stored in an associative array.

As the test program executes, traditional imperative logic implements
the DANE client and tests the server for correct responses. Whereas a
traditional tester might simply print the results, this tester instead
creates a list of \emph{DaneTestResult} objects. This list gets longer
as the test progresses towards completion. Most of the tester's
functions return a list of \emph{DaneTestResult} objects, which are
then concatenated to form the final result.

The \emph{DaneTestResult} object is a data structure that contains
structured information about whether each test passes or fails. The
slots of the object are:

\begin{tabularx}{\textwidth}{llX}
passed & boolean & True if the test passed \\
dnssec & boolean & True if the test was a DNS lookup and the result was secured with DNSSEC \\
dnsrelied & boolean & True if the DNS lookup was relied upon. (Some DNS lookups may not be relied upon. For example, a DNS name may map to two IP addresses, but only one may have a functioning server.)\\
hostname & str & The relevant hostname.\\
ipaddr & str & The relevant IP address \\
test & DaneTestResult & A reference to the (immutable) \emph{DaneTestResult} object that corresponds to the test.\\
what & str & The context of what was being tested when the test took place.\\
rdata & str & The DNS response data (which the getdns API calls rdata) that was used in the test, if the test involves a DNS query.\\
key & str & Additional information returned in a DNS query, such as an
MX preference or a DANE cryptographic key. \\
\end{tabularx}

How this works is illustrated in this snippet of code from the
function \emph{get\_dns\_ip} which is executed after an DNS query for
an MX RR:

\begin{lstlisting}
if a['type'] == getdns.RRTYPE_MX == request_type:
    what = 'DNS MX lookup {} = {} {}'.format(hostname,rdata['preference'],rdata['exchange'])
    ret.append( DaneTestResult(passed=SUCCESS,
                               what=what,
                               dnssec=reply.get('dnssec_status'),
                               rdata=rdata,
                               data=rdata['exchange'],
                               key=rdata['preference']))
\end{lstlisting}

In this example, \emph{ret} is an array of \emph{DaneTestResult}
objects that will be returned. If an MX record is returned in the DNS
lookup, it's fields a broken out and added to \emph{ret[]}. DNS can
return multiple RRs in a query, and all of them are stored in
\emph{ret[]}.  They can then be both used in later parts of the test
and rendered for final output.


\section*{References}

\bibliography{rfc,fy16_report}


\end{document}

% LocalWords:  cryptographic modularization auditability exchanger MX
